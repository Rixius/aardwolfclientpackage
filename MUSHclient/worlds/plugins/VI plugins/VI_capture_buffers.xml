<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="VI_Capture_Buffers"
   author="Fiendish"
   id="dd10517422bc35b5131a3aa0"
   language="Lua"
   purpose="Capture buffers with keyboard navigation"
   date_written="2016-02-14"
   requires="5.01"
   version="0.1"
   save_state="y"
>

<description trim="y">
Capture buffers with keyboard navigation
</description>
  
</plugin>

<aliases>
<alias
   script="switch_to_buffer_by_name"
   match="mush buffer switch *"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="next_buffer"
   match="mush buffer next"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="prev_buffer"
   match="mush buffer prev"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="list_buffers"
   match="mush buffer list*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="next_line"
   match="mush buffer next line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="prev_line"
   match="mush buffer prev line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="last_line"
   match="mush buffer last line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="first_line"
   match="mush buffer first line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="show_line"
   match="mush buffer show line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="delete_line"
   match="mush buffer delete line"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="clear_buffer"
   match="mush buffer clear"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="remove_buffer"
   match="mush buffer remove*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="disable_buffer"
   match="mush buffer disable*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="enable_buffer"
   match="mush buffer enable*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="loud_buffer"
   match="mush buffer loud*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="quiet_buffer"
   match="mush buffer quiet*"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   match="mush buffer help"
   enabled="y"
   sequence="100"
   ignore_case="y"
   send_to="12"
><send>
   for k, v in pairs(GetPluginAliasList(GetPluginID())) do
      match = GetPluginAliasOption(GetPluginID(), v, "match")
      if match ~= "mush buffer debug" and match ~= "mush buffer destroy" then
         show(match)
      end
   end
</send>
</alias>

<alias
   match="mush buffer destroy"
   enabled="y"
   sequence="100"
   ignore_case="y"
   send_to="12"
><send>
buffers_flags = {}
current_buffer = nil
DeleteVariable("buffers_flags")
DeleteVariable("current_buffer")
</send>
</alias>

<alias
   match="mush buffer debug"
   enabled="y"
   sequence="100"
   ignore_case="y"
   send_to="12"
><send>
require "tprint"
print(current_buffer)
print(current_buffer_index)
tprint(buffers_flags)
tprint(sorted_buffer_indices)
tprint(lines)
</send>
</alias>

</aliases>

<script>
<![CDATA[

require "pairsbykeys"
MAX_BUFFER_LINES = 1000

-- date_format = "%d %b %H:%M:%S"   -- 30 Aug 13:29:49   date and time 24 hour
-- date_format = "%d %b %I:%M:%S%p" -- 30 Aug 01:20:12PM date and time 12 hour
-- date_format = "%H:%M:%S"         -- 13:29:08          time 24 hour
-- date_format = "%X"               -- 1:22:06 PM        time 12 hour
date_format = GetVariable("date_format") or "%d %b %H:%M:%S"
log_to_file = tonumber(GetVariable("log_to_file")) or 0
log_timestamps = tonumber(GetVariable("log_timestamps")) or 1

lines = {} -- per-session buffer storage
current_buffer_line = {} -- per-session current line indices for each buffer
current_buffer = GetVariable("current_buffer") -- which buffer is currently viewed
loadstring(GetVariable("buffers_flags") or "buffers_flags = {}")() -- store which buffers are enabled/quiet/loud/etc
sorted_buffer_indices = {}

require "serialize"
function OnPluginSaveState()
   SetVariable("date_format", date_format)
   SetVariable("log_to_file", log_to_file)
   SetVariable("log_timestamps", log_timestamps)
   if buffers_flags then
      SetVariable("buffers_flags", serialize.save("buffers_flags"))
   end
   if current_buffer  then
      SetVariable("current_buffer", current_buffer)
   end
end

-- Returns an array {start, end, text}
function findURLs(text)
   local URLs = {}
   local start, position = 0, 0
   -- "rex" is a table supplied by MUSHclient for PCRE functionality.
   local re = rex.new("(?:https?://|mailto:)\\S*[\\w/=@#\\-\\?]")
   re:gmatch(text,
      function (link, _)
         start, position = string.find(text, link, position, true)
         table.insert(URLs, {start=start, stop=position, text=link})
      end
   )
   return URLs
end

function reindex_buffers()
   sorted_buffer_indices = {}
   
   for k in pairs(lines) do
      table.insert(sorted_buffer_indices, k)
   end
   table.sort(sorted_buffer_indices)
   
   if not current_buffer or not lines[current_buffer] then
      current_buffer = sorted_buffer_indices[1]
   end
   current_buffer_index = get_buffer_index(current_buffer)
   OnPluginSaveState()
end

function add_buffer_if_new(buffer, prevent_reindex)
   if not buffers_flags[buffer] then
      buffers_flags[buffer] = {capture=true, autoecho=true}
      lines[buffer] = {}
      current_buffer_line[buffer] = current_buffer_line[buffer] or 1
      
      if not prevent_reindex then
         reindex_buffers()
      end
   end
end

function get_buffer_index(buffer)
   for i,v in ipairs(sorted_buffer_indices) do
      if v == buffer then
         return i
      end
   end
end

function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-]", "")
   return Trim(str)
end

function stamp_and_store(buffer, msg)
   local text = ""
   local log_text = ""
    
   -- inject timestamp if wanted
   timestamp = os.date(date_format)
   
   if (log_to_file == 1) then
      if (log_timestamps == 0) then
         log_text = msg
      else
         log_text = timestamp..msg
      end
      local filename = GetInfo(58):gsub("^.\\",GetInfo(56))..sanitize_filename(GetInfo(2)).."BufferLog.txt"
      local f, err = io.open (filename, "a+") -- handle to buffer log file
      if f then
         f:write(log_text.."\n") -- write to it
         f:close()  -- close that file now
      else
         show("BUFFER LOG ERROR: Failed to access your buffer logging file because of the following reason:" )
         show(err)
         show("Fix the problem or disable Logging to File in the "..GetPluginInfo(1).." plugin.")
      end
   end

   local urls = findURLs(msg)
   -- store the lines
   add_buffer_if_new(buffer)
   if buffers_flags[buffer].capture then
      if #(lines[buffer]) >= MAX_BUFFER_LINES then
         table.remove(lines[buffer], 1)
      end
      table.insert(lines[buffer], {["msg"]=msg, ["urls"]=urls, ["timestamp"]=timestamp})
   end
   if buffers_flags[buffer].autoecho then
      show(msg)
   end
end

function list_buffers(name, line, wildcards)
   local flag = Trim(wildcards[1])
   if flag == "" or flag == "all" then 
      flag = "known" 
   end
   if flag=="known" or flag=="enabled" or flag=="disabled" or flag=="loud" or flag=="quiet" then
      show("The following buffers are",flag,":")
      for k,bflags in pairsByKeys(buffers_flags) do
         if (flag == "known") or (flag=="enabled" and bflags.capture) or (flag=="disabled" and not bflags.capture) or (flag=="loud" and bflags.autoecho) or (flag=="quiet" and not bflags.autoecho) then
            show(k, bflags.autoecho and "loud" or "quiet", lines[k] and #(lines[k]) or 0)
         end
      end
   else
      show("Invalid list option \""..flag.."\". Choices are enabled, disabled, loud, quiet, all.")
   end
   show("")
end

function switch_to_buffer(buffer)
   current_buffer = buffer
   show("Switched to buffer for",buffer)

   local buffer_lines = #(lines[buffer])
   if buffer_lines > 0 then
      local current_line = current_buffer_line[buffer] or math.min(1, buffer_lines)
      current_buffer_line[buffer] = current_line
   end

   show_line()
   OnPluginSaveState()
end

function switch_to_buffer_by_name(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffers_flags[buffer] and buffers_flags[buffer].capture then
      current_buffer_index = get_buffer_index(buffer)
      switch_to_buffer(buffer)
   else
      show(buffer,"is not a buffer.")
   end
end

function next_buffer()
   if #sorted_buffer_indices > 1 then
      current_buffer_index = current_buffer_index+1
      if current_buffer_index > #sorted_buffer_indices then
         current_buffer_index = 1
      end
      switch_to_buffer(sorted_buffer_indices[current_buffer_index])
   else
      show("There are no other buffers.")
   end
end

function prev_buffer()
   if #sorted_buffer_indices > 1 then
      current_buffer_index = current_buffer_index-1
      if current_buffer_index < 1 then
         current_buffer_index = #sorted_buffer_indices
      end
      switch_to_buffer(sorted_buffer_indices[current_buffer_index])
   else
      show("There are no other buffers.")
   end
end

function next_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   if #(lines[buffer]) > 0 then
      current_buffer_line[buffer] = math.min(current_buffer_line[buffer]+1, #(lines[buffer]))
   end
   show_line()
end

function prev_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   if #(lines[buffer]) > 0 then
      current_buffer_line[buffer] = math.max(current_buffer_line[buffer]-1, 1)
   end
   show_line()
end

function last_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   if #(lines[buffer]) > 0 then
      current_buffer_line[buffer] = #(lines[buffer])
   end
   show_line()
end

function first_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   if #(lines[buffer]) > 0 then
      current_buffer_line[buffer] = 1
   end
   show_line()
end

function show_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   if #(lines[buffer]) > 0 then
      local current_line = current_buffer_line[buffer]
      show(buffer,"line", current_line, "of", #(lines[buffer]), "at", lines[buffer][current_line].timestamp, lines[buffer][current_line].msg)
   else
      show("Buffer for",buffer,"is empty.")
   end
end

function delete_line()
   local buffer = sorted_buffer_indices[current_buffer_index]
   local current_line = current_buffer_line[buffer]
   local num_lines = #(lines[buffer])
   if num_lines > 0 then
      show("Deleting line",current_line,"of",num_lines,"from",buffer,"buffer")
      table.remove(lines[buffer], current_line)
   end
   show_line()
end

function clear_buffer()
   local buffer = sorted_buffer_indices[current_buffer_index]
   lines[buffer] = {}
   current_buffer_line[buffer] = 1
   show("Buffer for",buffer,"is cleared.")
end

function quiet_buffer(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffer == "" then buffer = current_buffer end
   if buffer == "all" then
      for k,v in pairs(buffers_flags) do
         v.autoecho = false
      end
      show("Auto speaking for all buffers disabled.")
   elseif buffers_flags[buffer] then
      buffers_flags[buffer].autoecho = false
      show("Auto speaking for",buffer,"disabled.")
   elseif buffer then
      show(buffer,"is not a buffer.")
   end
   OnPluginSaveState()
end

function loud_buffer(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffer == "" then buffer = current_buffer end
   if buffer == "all" then
      for k,v in pairs(buffers_flags) do
         v.autoecho = true
      end
      show("Auto speaking for all buffers enabled.")
   elseif buffers_flags[buffer] then
      buffers_flags[buffer].autoecho = true
      show("Auto speaking for",buffer,"enabled.")
   elseif buffer then
      show(buffer,"is not a buffer.")
   end
   OnPluginSaveState()
end

function remove_buffer(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffer == "" then 
      buffer = current_buffer 
      next_buffer()
   end
   if buffers_flags[buffer] then
      line[buffer] = nil
      buffers_flags[buffer] = nil
      reindex_buffers()
      show("Buffer for",buffer,"is removed.")
   else
      show(buffer,"is not a buffer.")
   end
   OnPluginSaveState()
end

function disable_buffer(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffer == "" then buffer = current_buffer end
   if buffer == "all" then
      lines = {}
      for k,v in pairs(buffers_flags) do
         v.capture = false
      end
      show("All buffers disabled.")
      reindex_buffers()
   elseif buffers_flags[buffer] and buffers_flags[buffer].capture then
      if current_buffer == buffer then
         next_buffer()
      end
      buffers_flags[buffer].capture = false
      lines[buffer] = nil
      show("Buffer for",buffer,"is disabled.")
      reindex_buffers()
   elseif buffer then
      show(buffer,"is not a buffer.")
   else
      show("There are no capture buffers.")
   end
   OnPluginSaveState()
end

function enable_buffer(name, line, wildcards)
   local buffer = Trim(wildcards[1])
   if buffers_flags[buffer] and buffers_flags[buffer].capture then
      show(buffer,"is already a buffer.")
   else
      function ena(buffer)
         buffers_flags[buffer] = {capture=true}
         lines[buffer] = {}
         current_buffer_line[buffer] = current_buffer_line[buffer] or 1
      end
      if buffer == "all" then
         for k,v in pairs(buffers_flags) do
            ena(k)
         end
         show("All buffers enabled.")
         reindex_buffers()
      else
         if buffer ~= "" then
            ena(buffer)
            show("Buffer for",buffer,"is enabled.")
            reindex_buffers()
         else
            show("Invalid buffer name given.")
         end
      end
   end
   OnPluginSaveState()
end

function OnPluginInstall()
end

function show(...)
   print(...) -- replace this with TTS
end

]]>
</script>
</muclient>
